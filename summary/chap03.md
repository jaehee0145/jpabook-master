# chap03 영속성 관리  

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저 
- 엔티티 매니저 팩토리 
    - 생성 비용이 크다.
    - 여러 스레드가 동시에 접근해도 안전하므로 스레드 간 공유
    - 하이버네이트를 포함한 JPA 구현체들은 엔티티 매니저 팩토리를 생성할 때 커넥션풀도 만든다.
- 엔티티 매니저 
    - 필요할 때마다 엔티티 매니저 팩토리에서 엔티티 매니저를 생성  
    - 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 공유하면 안된다.  
    - 보통 트랜잭션을 시작할 때 커넥션을 획득한다.  

## 3.2 영속성 컨텍스트란? 
- JPA를 이해하는데 가장 중요한 용어는 영속성 컨텍스트 persistence context  
- 엔티티를 영구 저장하는 환경이라는 뜻  
- `em.persist(memner)`  : 엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다.

## 3.3 엔티티의 생명주기
<img width="456" alt="스크린샷 2021-06-28 오후 10 22 25" src="https://user-images.githubusercontent.com/45681372/123643447-57b67480-d85f-11eb-9a67-9c681bf0dd3b.png">  

1. 비영속(new/transient)
 - 영속성 컨텍스트와 전혀 관계가 없는 상태  
 - 순수한 객체 상태이며 아직 저장하지 않았다.  
```java 
Member member = new Member();
member.setId("1L");
member.setName("foo");  
```

2. 영속(managed)
- 영속성 컨텍스트에 저장된 상태  
- 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다.
```java
em.persist(member);
```

3. 준영속(detached)
- 영속성 컨텍스트에 저장되었다가 분리된 상태  
```java
em.detach(member); // 특정 엔티티를 준영속 상태로 만들거나  
em.close(); // 영속성 컨텍스트를 닫거나  
em.clear(); // 영속성 컨텍스트를 초기화 
```

4. 삭제(removed)
- 삭제된 상태

## 3.4 영속성 컨텍스트의 특징  
- 식별자 값  
    - 엔티티를 구분하는 식별자 값이 반드시 있어야 한다.  
- 데이터베이스 저장  
    - 플러시: JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영  
- 영속성 컨텍스트 장점
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지 
    - 지연 로딩  
    
1. 엔티티 조회 
    <img width="697" alt="스크린샷 2021-06-28 오후 10 32 52" src="https://user-images.githubusercontent.com/45681372/123644894-c8aa5c00-d860-11eb-83a3-d382f0331644.png">
    - 1차 캐시: 영속성 컨텍스트는 내부 캐시
    - 1차 캐시의 키는 식별자 값  
    - **성능상 이점**:  
    `em.find()` 를 호출하면 1차 캐시에서 엔티티 찾기  
        -> 없으면 DB 조회해서 엔티티 생성   
        -> 1차 캐시에 저장  
        -> 영속 상태의 엔티티 반환     
    - **동일성 보장**: `em.find()` 를 연속 호출하면 1차 캐시에 있는 같은 엔티티 인스턴스를 반환

2. 엔티티 등록  
    <img width="592" alt="스크린샷 2021-06-28 오후 10 43 09" src="https://user-images.githubusercontent.com/45681372/123646489-3905ad00-d862-11eb-8c72-a8b8b31c5205.png">
    - 쓰기 지연 transactional write-behind: 엔티티 매니저 내부 쿼리 저장소에 쿼리를 모았다가 트랜잭션 커밋할 때 보냄  
    - 회원 A를 영속화  
        -> 1차 캐시에 회원 엔티티를 저장하면서 등록 쿼리를 쓰기 지연 SQL 저장소에 보관  
        -> 트랜잭션 커밋  
        -> 플러시(쓰기 지연 SQL 저장소에 모인 쿼리를 디비에 보낸다.)
    - 모아둔 쿼리를 디비에 한 번에 전달해서 성능을 최적화할 수 있다.  
    
3. 엔티티 수정  
    <img width="772" alt="스크린샷 2021-06-28 오후 10 47 31" src="https://user-images.githubusercontent.com/45681372/123647184-d3fe8700-d862-11eb-9a8d-da9de5b3b09c.png">
    - 변경 감지 dirth checking : 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능  
    - 스냅샷 : 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장
    - 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
    - 트랜잭션 커밋  
        -> 엔티티 매니저 내부에서 플러시 호출
        -> 엔티티와 스냅샷 비교해서 변경된 엔티티 찾기  
        -> 변경된 엔티티에 대한 수정 쿼리 생성해서 쓰기 지연 SQL 저장소에 보관  
        -> 쓰기 지연 SQL 저장소 쿼리를 디비에 보내기  
        -> 디비 트랜잭션을 커밋  
    - 수정 쿼리
        - 기본 전략: 엔티티의 모든 필드를 업데이트
            - 장점: 모든 필드를 사용하면 수정 쿼리가 항상 같아 재사용 가능 
        - 동적 업데이트 전략 : 수정된 데이터만 사용해서 동적 update sql 생성  
            - 필드가 많거나 저장되는 내용이 큰 경우 
            
4. 엔티티 삭제  
    - 엔티티 등록과 비슷하게 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록
    - 삭제된 엔티티는 재사용하지 말고 가비지 컬렉션의 대상이 되도록 두는 것이 좋다. 

5. 플러시 
   - 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영  
     - 1. 플러시 실행
     - 2. 스냅샷과 비교해서 수정된 엔티티 찾기
     - 3. 수정 쿼리를 만들어 쓰기 지연 SQL저장소에 등록
     - 4. 쿼리를 디비에 전송
   - 플러시하는 방법
     - 1. em.flush() 직접 호출  
       - 거의 사용하지 않는다.
     - 2. 트랜잭션 커밋시 플러시가 자동 호출된다.
       - 트랜잭션만 커밋하면 디비에 반영이 되지 않기 때문에
     - 3. JPQL 쿼리 실행시 플러시가 자동 호출된다. 
       - 영속성 컨텍스트에는 있지만 디비에 반영되지 않은 데이터를 처리하기 위해
6. 준영속
   - 영속성 컨텍스트에서 분리된 것 
   

